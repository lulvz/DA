<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGraph_1_1edgeNode.html">edgeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGraph_1_1vertexNode.html">vertexNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a18565471ddae78ed92b97efa36fe796b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a18565471ddae78ed92b97efa36fe796b">Graph</a> (bool dir)</td></tr>
<tr class="separator:a18565471ddae78ed92b97efa36fe796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115f041456adfe9168c826980f7d7122"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a115f041456adfe9168c826980f7d7122">getNumVertices</a> () const</td></tr>
<tr class="separator:a115f041456adfe9168c826980f7d7122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f46cf7e705174d9596e2e3030695b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a36f46cf7e705174d9596e2e3030695b5">getNumEdges</a> () const</td></tr>
<tr class="separator:a36f46cf7e705174d9596e2e3030695b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b970ecb424505f85c4f9d632b5ab01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a08b970ecb424505f85c4f9d632b5ab01">isDirected</a> () const</td></tr>
<tr class="separator:a08b970ecb424505f85c4f9d632b5ab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa698d2cdd5da4278f08ff3c510eb2af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aaa698d2cdd5da4278f08ff3c510eb2af">setVertexInfo</a> (int vertex, std::string name, std::string district, std::string municipality, std::string township, std::string line)</td></tr>
<tr class="separator:aaa698d2cdd5da4278f08ff3c510eb2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd4d9cfb21e1b80c9d3bb6ec6537b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7dd4d9cfb21e1b80c9d3bb6ec6537b44">addVertex</a> (int vertex, std::string name, std::string district, std::string municipality, std::string township, std::string line)</td></tr>
<tr class="separator:a7dd4d9cfb21e1b80c9d3bb6ec6537b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e44a4d6cce4acb70c50e0101a014ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6e44a4d6cce4acb70c50e0101a014ed8">addEdge</a> (int v1, int v2, int capacity, std::string service)</td></tr>
<tr class="separator:a6e44a4d6cce4acb70c50e0101a014ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8f018332a32129b078d07f621d85ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aed8f018332a32129b078d07f621d85ff">removeEdge</a> (int v1, int v2)</td></tr>
<tr class="separator:aed8f018332a32129b078d07f621d85ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f399c2f36805a3a2342a7a24258127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a35f399c2f36805a3a2342a7a24258127">removeAdjEdges</a> (int v)</td></tr>
<tr class="separator:a35f399c2f36805a3a2342a7a24258127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bb4ceb690e3cce0d7866d7678b88c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae0bb4ceb690e3cce0d7866d7678b88c2">most_trains_for_network_cap</a> ()</td></tr>
<tr class="separator:ae0bb4ceb690e3cce0d7866d7678b88c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc4f83a5041828ef9e1f5b45ac3905b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7fc4f83a5041828ef9e1f5b45ac3905b">top_k_municipalities_capacity</a> ()</td></tr>
<tr class="separator:a7fc4f83a5041828ef9e1f5b45ac3905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adac4781106e6805f9ec34720d955eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9adac4781106e6805f9ec34720d955eb">top_k_districts_capacity</a> ()</td></tr>
<tr class="separator:a9adac4781106e6805f9ec34720d955eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bd24427e2b64f9cbeddcc9dd75ed1f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae1bd24427e2b64f9cbeddcc9dd75ed1f">top_k_districts_flow</a> ()</td></tr>
<tr class="separator:ae1bd24427e2b64f9cbeddcc9dd75ed1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2567ff428ed08add5b93b79e25aaea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9a2567ff428ed08add5b93b79e25aaea">top_k_municipalities_flow</a> ()</td></tr>
<tr class="separator:a9a2567ff428ed08add5b93b79e25aaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b32bbaf88b2592cb03c11c758da3493"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0b32bbaf88b2592cb03c11c758da3493">max_trains_arriving_at</a> (int vertex)</td></tr>
<tr class="separator:a0b32bbaf88b2592cb03c11c758da3493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692d5e808eef1b5ec9db213a42b502e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a692d5e808eef1b5ec9db213a42b502e5">bfs</a> (int source, int sink, std::vector&lt; int &gt; &amp;parent)</td></tr>
<tr class="separator:a692d5e808eef1b5ec9db213a42b502e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea10c924e17aabb8750bc0cf9fe0b15e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aea10c924e17aabb8750bc0cf9fe0b15e">ford_fulkerson</a> (int source, int sink)</td></tr>
<tr class="separator:aea10c924e17aabb8750bc0cf9fe0b15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1e40b29fcd7638549cfc0398c55bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1c1e40b29fcd7638549cfc0398c55bda">sub_graph_without_segments</a> (std::vector&lt; std::pair&lt; int, int &gt;&gt; segments)</td></tr>
<tr class="separator:a1c1e40b29fcd7638549cfc0398c55bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a716b336f029f8a7b5d1b75da960cc"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad9a716b336f029f8a7b5d1b75da960cc">max_flow_per_station</a> ()</td></tr>
<tr class="separator:ad9a716b336f029f8a7b5d1b75da960cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd4a787a888a5c7ce541d6976fea213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7dd4a787a888a5c7ce541d6976fea213">dijkstra</a> (int vertex1, int vertex2, std::vector&lt; int &gt; &amp;dist, std::vector&lt; int &gt; &amp;parent)</td></tr>
<tr class="separator:a7dd4a787a888a5c7ce541d6976fea213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d92f7b458626064784c94a68072338"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a74d92f7b458626064784c94a68072338">min_cost_max_flow</a> (int vertex1, int vertex2)</td></tr>
<tr class="separator:a74d92f7b458626064784c94a68072338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac05db53839e72af76cdb2bafe88b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5ac05db53839e72af76cdb2bafe88b77">printGraph</a> ()</td></tr>
<tr class="separator:a5ac05db53839e72af76cdb2bafe88b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64516282c804cd4b2029f8a8c6c2d968"><td class="memItemLeft" align="right" valign="top"><a id="a64516282c804cd4b2029f8a8c6c2d968"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test</b> ()</td></tr>
<tr class="separator:a64516282c804cd4b2029f8a8c6c2d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7ab6afa73688e56e8abcddd107974550"><td class="memItemLeft" align="right" valign="top"><a id="a7ab6afa73688e56e8abcddd107974550"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_vertices</b></td></tr>
<tr class="separator:a7ab6afa73688e56e8abcddd107974550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab614971163b3d27721f24a7c17e0519d"><td class="memItemLeft" align="right" valign="top"><a id="ab614971163b3d27721f24a7c17e0519d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges</b></td></tr>
<tr class="separator:ab614971163b3d27721f24a7c17e0519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3111bb6cc59aedbc4290ed1b37668336"><td class="memItemLeft" align="right" valign="top"><a id="a3111bb6cc59aedbc4290ed1b37668336"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>directed</b></td></tr>
<tr class="separator:a3111bb6cc59aedbc4290ed1b37668336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c8a01cced3f71153e3eb8f044adf50"><td class="memItemLeft" align="right" valign="top"><a id="ac7c8a01cced3f71153e3eb8f044adf50"></a>
std::vector&lt; <a class="el" href="structGraph_1_1vertexNode.html">vertexNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b></td></tr>
<tr class="separator:ac7c8a01cced3f71153e3eb8f044adf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a18565471ddae78ed92b97efa36fe796b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18565471ddae78ed92b97efa36fe796b">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construtor da classe <a class="el" href="classGraph.html">Graph</a>. Este método tem complexidade de tempo O(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>true se o grafo for direcionado, false caso contrário. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e44a4d6cce4acb70c50e0101a014ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e44a4d6cce4acb70c50e0101a014ed8">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adiciona uma aresta ao grafo. Este método tem complexidade de tempo O(E), onde E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
    <tr><td class="paramname">capacity</td><td></td></tr>
    <tr><td class="paramname">service</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dd4d9cfb21e1b80c9d3bb6ec6537b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd4d9cfb21e1b80c9d3bb6ec6537b44">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>district</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>municipality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>township</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adiciona um vertice ao grafo. Este método tem complexidade de tempo O(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">district</td><td></td></tr>
    <tr><td class="paramname">municipality</td><td></td></tr>
    <tr><td class="paramname">township</td><td></td></tr>
    <tr><td class="paramname">line</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692d5e808eef1b5ec9db213a42b502e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692d5e808eef1b5ec9db213a42b502e5">&#9670;&nbsp;</a></span>bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::bfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algoritmo Breadth First Search Realiza uma busca em largura no grafo a partir do vertice s Este algomritmo tem complexidade de tempo O(V + E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>vertice de partida </td></tr>
    <tr><td class="paramname">t</td><td>vertice de destino </td></tr>
    <tr><td class="paramname">parent</td><td>vetor de pais </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true se existe um caminho de s a t, false caso contrario </dd></dl>

</div>
</div>
<a id="a7dd4a787a888a5c7ce541d6976fea213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd4a787a888a5c7ce541d6976fea213">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algoritmo de Dijkstra modificado para encontrar o caminho menos dispendioso entre dois vértices. Este método tem em conta os serviços de comboios, optando por um caminho mais barato, mesmo que seja mais longo. Este método tem complexidade de tempo O(V^2), onde V é o número de vértices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex1</td><td>vértice de partida. </td></tr>
    <tr><td class="paramname">vertex2</td><td>vértice de chegada. </td></tr>
    <tr><td class="paramname">dist</td><td>vetor com as distâncias entre o vértice de partida e todos os outros vértices. </td></tr>
    <tr><td class="paramname">parent</td><td>vetor com os pais de cada vértice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea10c924e17aabb8750bc0cf9fe0b15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea10c924e17aabb8750bc0cf9fe0b15e">&#9670;&nbsp;</a></span>ford_fulkerson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::ford_fulkerson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algoritmo Ford Fulkerson. Percorre o grafo a partir do vertice source ate o vertice sink, e encontra o fluxo maximo. Este algoritmo tem complexidade de tempo O(V * E^2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>vertice de partida. </td></tr>
    <tr><td class="paramname">sink</td><td>vertice de destino. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>o fluxo maximo. </dd></dl>

</div>
</div>
<a id="a36f46cf7e705174d9596e2e3030695b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f46cf7e705174d9596e2e3030695b5">&#9670;&nbsp;</a></span>getNumEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getNumEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retorna o número de arestas do grafo. Este método tem complexidade de tempo O(1). </p><dl class="section return"><dt>Returns</dt><dd>número de arestas do grafo. </dd></dl>

</div>
</div>
<a id="a115f041456adfe9168c826980f7d7122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115f041456adfe9168c826980f7d7122">&#9670;&nbsp;</a></span>getNumVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retorna o número de vértices do grafo. Este método tem complexidade de tempo O(1). </p><dl class="section return"><dt>Returns</dt><dd>número de vértices do grafo. </dd></dl>

</div>
</div>
<a id="a08b970ecb424505f85c4f9d632b5ab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b970ecb424505f85c4f9d632b5ab01">&#9670;&nbsp;</a></span>isDirected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isDirected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retorna se o grafo é direcionado ou não. Este método tem complexidade de tempo O(1). </p><dl class="section return"><dt>Returns</dt><dd>true se o grafo for direcionado, false caso contrário. </dd></dl>

</div>
</div>
<a id="ad9a716b336f029f8a7b5d1b75da960cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a716b336f029f8a7b5d1b75da960cc">&#9670;&nbsp;</a></span>max_flow_per_station()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, int &gt; Graph::max_flow_per_station </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve um mapa com o fluxo máximo entre cada estação. Este método tem complexidade de tempo O(V^2 * E), onde V é o número de vértices e E é o número de arestas. </p><dl class="section return"><dt>Returns</dt><dd>mapa com o fluxo máximo entre cada estação. </dd></dl>

</div>
</div>
<a id="a0b32bbaf88b2592cb03c11c758da3493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b32bbaf88b2592cb03c11c758da3493">&#9670;&nbsp;</a></span>max_trains_arriving_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::max_trains_arriving_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve o número máximo de comboios que podem chegar ao mesmo tempo a uma estação. Este método tem complexidade de tempo O(V * E), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>vértice da estação. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>número máximo de comboios que podem chegar ao mesmo tempo a uma estação. </dd></dl>

</div>
</div>
<a id="a74d92f7b458626064784c94a68072338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d92f7b458626064784c94a68072338">&#9670;&nbsp;</a></span>min_cost_max_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Graph::min_cost_max_flow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve o fluxo máximo entre dois vértices pertencentes a um caminho menos dispendioso. Este método tem complexidade de tempo O(V^2 * E), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex1</td><td>vértice de partida. </td></tr>
    <tr><td class="paramname">vertex2</td><td>vértice de chegada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fluxo máximo entre dois vértices. </dd></dl>

</div>
</div>
<a id="ae0bb4ceb690e3cce0d7866d7678b88c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bb4ceb690e3cce0d7866d7678b88c2">&#9670;&nbsp;</a></span>most_trains_for_network_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; Graph::most_trains_for_network_cap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve os possiveis caminhos onde podem circular o maior número de comboios em simultâneo. Este método tem complexidade de tempo O(V^2/2 * f * E), onde V é o número de vértices, f é o número de fluxo máximo e E é o número de arestas. </p><dl class="section return"><dt>Returns</dt><dd>vector de pares de strings com os nomes das estações de partida e chegada. </dd></dl>

</div>
</div>
<a id="a5ac05db53839e72af76cdb2bafe88b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac05db53839e72af76cdb2bafe88b77">&#9670;&nbsp;</a></span>printGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imprime o grafo. Este método tem complexidade de tempo O(V + E), onde V é o número de vértices e E é o número de arestas. </p>

</div>
</div>
<a id="a35f399c2f36805a3a2342a7a24258127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f399c2f36805a3a2342a7a24258127">&#9670;&nbsp;</a></span>removeAdjEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeAdjEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove todas as arestas adjacentes a um vértice. Este método tem complexidade de tempo O(d_v), onde d_v é o grau do vértice v. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed8f018332a32129b078d07f621d85ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8f018332a32129b078d07f621d85ff">&#9670;&nbsp;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove uma aresta do grafo. Este método tem complexidade de tempo O(d_v1 + d_v2), onde d_v1 e d_v2 são os graus dos vértices v1 e v2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td></td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa698d2cdd5da4278f08ff3c510eb2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa698d2cdd5da4278f08ff3c510eb2af">&#9670;&nbsp;</a></span>setVertexInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::setVertexInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>district</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>municipality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>township</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Muda as informações de um vertice no grafo. Este método tem complexidade de tempo O(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">district</td><td></td></tr>
    <tr><td class="paramname">municipality</td><td></td></tr>
    <tr><td class="paramname">township</td><td></td></tr>
    <tr><td class="paramname">line</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c1e40b29fcd7638549cfc0398c55bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1e40b29fcd7638549cfc0398c55bda">&#9670;&nbsp;</a></span>sub_graph_without_segments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> Graph::sub_graph_without_segments </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt;&gt;&#160;</td>
          <td class="paramname"><em>segments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cria um novo grafo com os vértices e arestas do grafo original, mas sem as arestas que ligam os vértices dos segmentos. Este método tem complexidade de tempo O(V + E), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>vector de pares de inteiros com os vértices que ligam os segmentos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>novo grafo com os vértices e arestas do grafo original, mas sem as arestas que ligam os vértices dos segmentos. </dd></dl>

</div>
</div>
<a id="a9adac4781106e6805f9ec34720d955eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adac4781106e6805f9ec34720d955eb">&#9670;&nbsp;</a></span>top_k_districts_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, int &gt; &gt; Graph::top_k_districts_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve os k distritos com maior necessidade de capacidade de transporte de comboios, em termos de capacidade. Este método tem complexidade de tempo O(V * E + V * log(V)), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>número de distritos a devolver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector de pares de strings com os nomes dos distritos e a sua capacidade. </dd></dl>

</div>
</div>
<a id="ae1bd24427e2b64f9cbeddcc9dd75ed1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bd24427e2b64f9cbeddcc9dd75ed1f">&#9670;&nbsp;</a></span>top_k_districts_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, int &gt; &gt; Graph::top_k_districts_flow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve os k distritos com maior necessidade de capacidade de transporte de comboios em termos de fluxo. Este método tem complexidade de tempo O(V^2 * E + V * log(V)), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>número de distritos a devolver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector de pares de strings com os nomes dos distritos e o seu fluxo. </dd></dl>

</div>
</div>
<a id="a7fc4f83a5041828ef9e1f5b45ac3905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc4f83a5041828ef9e1f5b45ac3905b">&#9670;&nbsp;</a></span>top_k_municipalities_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, int &gt; &gt; Graph::top_k_municipalities_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve os k municípios com maior necessidade de capacidade de transporte de comboios, em termos de capacidade. Este método tem complexidade de tempo O(V * E + V * log(V)), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>número de municípios a devolver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector de pares de strings com os nomes dos municípios e a sua capacidade. </dd></dl>

</div>
</div>
<a id="a9a2567ff428ed08add5b93b79e25aaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2567ff428ed08add5b93b79e25aaea">&#9670;&nbsp;</a></span>top_k_municipalities_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, int &gt; &gt; Graph::top_k_municipalities_flow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Devolve os k municípios com maior necessidade de capacidade de transporte de comboios em termos de fluxo. Este método tem complexidade de tempo O(V^2 * E + V * log(V)), onde V é o número de vértices e E é o número de arestas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>número de municípios a devolver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector de pares de strings com os nomes dos municípios e o seu fluxo. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="graph_8h_source.html">graph.h</a></li>
<li>src/ford_fulkerson.cpp</li>
<li>src/graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
